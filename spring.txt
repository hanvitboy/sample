트랜잭션 관리
조개질수 없는 하나의 작업 단위: 트랜잭션
acid 수정

atomicity 원자성
-하나의 트랜잭션은 모두 하나의 단위로 처리되어야한다.
-하나의 트랜잭션 안에 a,b이 두작업이 포함되어있는경우
-a는 성공했지만 b는 실패할경우 전체가 실패한것으로 간주하고 원래상태로 되돌린다.
-a와 b의 실행결과를 동일한 결과로 한다. 모두 성공 혹은 모두 실패한 상태로 만든다.

consistency 일관성
-트랜잭션이 성공했다면 데이터베이서의 모든 데이터는 일관성을 유지해야 한다.
-트랜잭션으로 처리된 데이터와 다른 데이터 사이에 전혀 차이가 없어야 한다.

isolation 격리성
-트랜잭션이 처리되는 중간에 외부에서 간섭할 수 없다.

durability 영속성
-트랜잭션이 성공적으로 처리가 되면 결과는 영속적으로 보관되어야 한다.

정규화 : 중복된 데이터를 제거해서 데이터 저장의 효율을 올린다.

person
이름, 주민번호, 주소, 성별 , .. . .
홍길동 00-000 서울 남   .. 

student
이름, 학번, 주민번호, 주소 , 성별..
홍길동  07  00-000  서울    남 ....

student
학번, 주민번호, . .. . . 
07   00 000    .... 

테이블의 조인을 이용해서 주민번호 컬럼(외래키)를 이용해서 그사람의 다른 테이블에있는 정보를 가져온다. 
where student.주민번호 = person.주민번호
정규화가 진행될수록 테이블은 점점더 순수한형태가된다 (꼭 필요한 정보만 저장하게 된다)

데이터조회할때 모든정보를 가져와야할때
조인할 테이블의 갯수가 늘어난다.

테이블을 조인한다 ? -> 컴퓨터가 조인이 필요한 테이블을 검색 -> 10만곱하기 10만 곱하기 10만
-컴퓨터가 할일이 너무 많아짐 . - 시간도 오래걸리고, 성능이 저하된다.

다시 테이블을 합쳐서 하나의 테이블에서 검색할 수 있도록 (조인 횟수를 줄인다)
반정규화 (어느정도 중복을 허용한다. 대신 조인,서브쿼리 이용횟수를 줄인다.)

스프링에서 트랜직선 기능을 제공
spring-tx spring jdbc spring ojdbc

트랜잭션 기능을 사용하기위해 필요했던 설정들
pom.xml 에서는
spring-tx, spring jdbc ojdbc
aop (aspectjrt, aspertjweaver) 의존성추가

스프링 설정파일 root-contextxml에는
	db 관련 설정 빈 (datasource , sql sessionfactory,)
	namespace 가서 aop tx 체크
	transactionManager 빈 추가, <tx:annotation-driven/>: 트랜잭션 설정을 어노테이션으로 하겠다.
	<aop:aspectj-autoproxy> : aop 설정을 어노테이션으로 하겠다.
우리가 사용할 메소드 (트랜잭션 처리하고 싶은 메소드) 위에 @transactional

rest 방식으로 전환
옛날 방식에서는 우리가 만든느 데이터의 소비자가 웹브라우저 (컴퓨터)
스마트폰(모바일)
서버의 데이터를 소비하는 주체가 웹 브라우저라는 특정한 어플리케이션으로 제한적.
->모바일기기가 많아지면서 모바일의 앱이나 웹도 서버에서 제공하는 데이터를 소비하게 되었다.

과거의 서버의 데이터 제공 대상 : 웹브라우저
최근 서버의 데이터제공 대상 : 웹브라우저 + 수많은 다양한 기기들(스마트폰)

스마트폰에서는 app 이라고 불리는 고유한 어플리케이션을 사용해서 데이터를 소비
스마트폰에서 보이는 화면은 더이상 html이 아니다. (자신만의 방법으로 화면을 제공)

REST (representational State Transfer)
하나의 URI는 하나의 고유한 resource(자원)을 대표하도록 설계
URI: 당신이 원하는 곳의 주소는 여기입니다. "/board/123"
URL: 이곳에 오면 당신이 원하는 것을 찾을수 있습니다.  
 이 주소는 123번 게시물을 위한 유일한 주소get/post 데이터전달하는 방식까지추가
 
rest = uri + get/post/put/delete/...

rest 방식이 되면 가장 먼저 기억해야하는것 : 서버의 변화
서버가 전송하는 것이 순수한 데이터가 된다.
기존의 컨트롤러에서 데이터를 담아서 jsp와 같은 view로 전달하는 방식이 아니다.

서버가 순수하게 데이터만 전달한다. -> 많이 사용하는 방식
json 방식으로 데이터를 전달한다.
xml방식 (옛날)
프로젝트에서 json 방식을 사용하기 위해 라이브러리 추가가 필요하다.

     작업			전송방식   				uri
create (등록) :   post			/board/new
read (조회)  :    get				/board/{id}
update(수정) :    put				/board/{id}
delete(삭제) :    delete			/board/{id}
crud 의 매칭

rest 방식을 이용해서 댓글 처리를 구현
+ ajax

댓글 테이블
create table tbl_reply (
	rno number(10,0),
	bno number(10,0) not null, //조인용
	reply varchar2(1000) not null,
	replyer varchar2(50) not null,
	replyDate date default sysdate,
	updateDate date default sysdate
);

create sequence seq_reply minvalue 0 maxvalue 99999999 increment by 1 start with 1 cycle;

alter table tbl_reply add constraint pk_reply primary key(rno);

alter table tbl_reply add constraint fk_reply_board foreign key (bno)
references tbl_board(bno);

댓글을 찾을때 bno 기준으로 어떤 게시물의 댓글을 가져올지 먼저정하는데
인덱스설정은 rno로만 되어있다.

현재 데이터베이스방식은
rno를 먼저찾고 (rno로 지정된 인덱스에서 rno를 먼저찾고)
그다음에 rno에 해당하는 bno를 찾게된다.
실제로 웹에서 찾는순서가 bno- > rno 이다.

--pk_reply만 이용해서 댓글 검색을 하다보니 중간에있는 다른 게시물의 댓글도
있을텐데 그 중간에 있는 다른게시물의 댓글수가 적을때는 괜찮지만 댓글이 많아지면 성능에 문제가 생길수있다.

즉 데이터베이스 검색하는 순서도 웹에서 댓글을 조회하는 순서같이 변경해야 성능을 올릴수가있다.
rno 가 아니라 bno를 기준으로 정렬해놓은 인덱스를 새성
create index 인덱스이름 on 테이블이름 (컬럼1,컬럼2...)

파일 업로드

첨부파일 설정은 프로젝트에 web.xml이 있는 경우에는 web.xml에서 처리해준다.
스프링 사용 시 multipartresolver 라는 타입의 객체를 빈으로 등록해서 사용
web과 관련된 설정이므로 servlet-context.xml을 이용해서 빈으로 등록

파일 업로드시 고려해야 하는 점들

동일한 이름으로 파일이 업로드 되었을때 기존 파일이 사라진다. (덮어쓰기 해버림)
네이버메일에서 파일업로드해려했더니 zip exe 이런 파일 업로드 막아버림
첨부파일 공격에 대비하기위해 업로드 파일의 확장자를 제한
파일크기가 너무 큰 경우 사전 처리

파일 이름 중복처리 방법
하나는 시간을 파일이름 앞에 붙여서 저장(일반적으로 많이 사용하는 방법)
또는 년/월/일 단위로 폴더 구조를 만들어서 저장
[2022]
	[05]
		[10]
			iu.jpg
2022_05_10_iu.jpg
UUID 범용 고유 식별자(네트워크상에서 고유성이 보장되는 ID)

이미지 크기가 너무 큰 경우 화면에 그대로 사용할 경우 많은 데이터를 소비해야한다.
모바일에서 웹페이지를 여는데 웹페이지에 엄청큰 이미지 파일이 포함되어 있다면
이미지파일의 크기만큼 남은 데이터를 소모
특별한경우가 아니면 이미지크기를 줄여서 썸네일처리가 필요하다.
썸네일 처리는 우리가 직접하지 않고 라이브러리를 가져와서 사용

SPRIng web security

로그인 처리를 하는데 사용되는 스프링프레임워크의 기능
사용자의 권한, 등급을 기반으로 로그인 체크를 사용
우리는 기본적으로 쿠키를 이용하거나 세션을 이용하는 방식으로 로그인 처리
스프링에서는 + 인터셉터를 이용해서 로그인 처리
인터셉터 vs 필터
필터는 jsp 의 서블릿에서 사용되는 개념
서블릿이 요청을 받아서 처리하기 전에 필요한 동작을 필터에서 해줬었다.
인코딩 작업, 널값 작업 후에 다음 단계로 요청을 전달
필터는 스프링과 무관한 서블릿의 자원

필터		서블릿범위
요청 ->	[|필터|-> 요청중간처리-> |서블릿|]

인터쎕터
		서블릿범위			스프링범위
요청 - > [|필터| - >   [ 인터셉터 - > 컨트롤러		]]


인터셉터는 스프링의 빈으로 관리되는 필터
인터셉터를 사용하면 스프링 내부에서관리되는 모든 자원들을 활용할수 있게 된다.

스프링 시큐리티 라이브러리를 추가하고 (pom.xml 에 dependency)
config, web, core+
스프링 시큐리티 전용설정파일 (xml을 root -context.xml 이 있는 위치에 추가
스프링mvc에서 시큐리티 기능을 사용하기 위해서 시큐리티가 서블릿 범위에서 동작하도록
WEB.XML에 필터로 등록함

스프링 시큐리티에서 가장 중요한 개념 두가지
인증 Authentification
권한 Authorization

인증:  자기자신을 증명 로그인
권한 : 다른사람이 자격을 부여해준 다는것.

어떤회사에 고장난 데이터베이스,프로그램을 고치기위해서 방문
회사 입구에서 여러분들이 누구인지를 물어본다.
아 나는 여기 회사에 고장난 데이터베이스를 고치기 위해서 온 엔지니어 홍길동 입니다.
본인 인증함. 신분증, 출입증 검사. 방문 예약이 되어있는지 확인

인증 성공후에 회사 내부에 들어간 홍길동은 다시 데이터베이스 담당자를 만나서
데이터베이스의 접근 권한 등의 정보를 얻어야한다. ==> 권한을 부여받아서 데이터베이스를 고친다.

스프링 시큐리티 설정 파일 작성할때 추가했던
AuthentificationManager - > 얘가 인증을 담당

접근 제한 설정

스프링 시큐리티와 jdbc를 같이 이용하는 방법
1) 스프링 시큐리티에서 지정한 형식으로 테이블을 생성해서 사용
2) 우리가 작성한 데이터베이스를 이용하는 방식

인증 / 권한을 위해 테이블을 생성
tbl_member : 회원정보 테이블
tbl_member_auth : 회원의 권한
패스워드를 그냥 그대로 사용했는데 패스워드 인코딩도 해보겟다.
암호화 처리..!

데이터베이스에 저장된 회원정보를 통해 인증을 할건데 필요한 쿼리 2개
사용자 정보를 인증하는데 필요한 쿼리
select userid, username, userpw, password, enabled
from tbl_member
where userid= '?';

그 사용자의 권한을 확인하는데 필요한 쿼리
select userid, auth
from tbl_member_auth
where userid= '?';

기무주현왔다감